#!/usr/bin/python3

#Global imports go here. These are the packages that we want to be sure are 
#available regardless of the functionality being accessed
import click
from blessed import Terminal
import os

@click.command()
@click.option("-l", "--log-level", default='info', help='Select log level from [error, warn, info, debug, trace]')
@click.option("--list-packages", default=None, is_flag=True)
@click.option("--show-package")
@click.argument("expression", default="")
def run(log_level, list_packages, show_package, expression):

    from actuator import log
    log.set_level(log_level)

    if list_packages:
        run_list_packages()
        return
    
    if show_package:
        run_show_package(show_package)
        return

    #support passing filename as expression, enables shebang functionality
    if os.path.exists(expression):
        fh = open(expression, 'r')
        expression = fh.read()
        fh.close()
        expression = "\n".join([l.strip() for l in expression.split("\n") if not l.strip().startswith("#")])
    
    
    if expression:
        run_expression(expression)
        return
    
    

def run_expression(expression):
    from actuator import log, util
    from actuator.lang import parser
    import sys
    flowset = parser.parse_actuator_expression(expression)

    
    util.set_global('expression', expression)
    
    flowset.setup()
    log.debug("Loaded flows:\n---\n {}".format(flowset.description))
    try:
        flowset.start()
    except BrokenPipeError:
        pass

    

    util.run_shutdown_hooks()
    sys.stderr.close()
    

def run_list_packages():
    from actuator import package
    term = Terminal()
    print("\n    " + term.underline(term.bold("Packages") + "\n"))
    for p in package.REGISTRY.packages:
        name = p.name or "<builtin>"
        print("      " + name)
    print("\n")

def run_show_package(show_package):
    from actuator import package
    term = Terminal()
    pkgname = show_package
    if pkgname == "builtin" or pkgname == "<builtin>":
        pkgname = None
    p = package.REGISTRY.get_package(pkgname)
    
    if not p:
        print("Could not find package '{}'".format(show_package))
        return
    
    print("\n    " + term.underline(term.bold("Package '{}'".format(show_package)) + "\n"))
    
    if p.sources.contents:
        print("      " + term.underline(term.bold("Sources") + "\n"))
        for sk, sv in p.sources.contents.items():
            name = sk or "<default>"
            print("        " + name)
        print("\n")
    
    if p.operators.contents:    
        print("      " + term.underline(term.bold("Operators") + "\n"))
        for sk, sv in p.operators.contents.items():
            name = sk or "<default>"
            print("        " + name)
        print("\n")
    
    if p.sinks.contents:
        print("      " + term.underline(term.bold("Sinks") + "\n"))
        for sk, sv in p.sinks.contents.items():
            name = sk or "<default>"
            print("        " + name)
        print("\n")
    
    
if __name__ == "__main__":
    run()
    
