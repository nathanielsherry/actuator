from actuator.lang import keywords
from actuator.package import REGISTRY

#Base class for intermediate objects/structs generated by parser
class Construct:
    @property
    def name(self):
        raise Exception("Unimplemented for {}".format(self.kind))

    @property
    def kind(self):
        return type(self).__name__
    
    def __repr__(self):
        return "<{kind}: {name}>".format(kind=self.kind, name=self.name)
    def __str__(self):
        return self.kind
    
    
    
#A reference to something 'elsewhere' A variable, a flow, etc
class Reference(Construct):
    def __init__(self, reference):
        self._reference = reference

    @property
    def reference(self): return self._reference

    @property
    def name(self): return self.reference

    def dereference(self, flowctx):
        raise Exception("Unimplemented")

class FlowReference(Reference):
    def dereference(self, flowctx):
        return flowctx.get_flow(self.reference)

class VariableReference(Reference):
    def dereference(self, flowctx):
        return flowctx.scope.get(self.reference)




#A sketch of what a component should look like eventually, a highly cusomized factory
class ComponentBlueprint(Construct):
    def __init__(self, package, params):
        self._package = package
        self._params = params
      
    @property
    def name(self):
        return self.package.path
    
    @property
    def package(self):
        return self._package
    
    @property
    def parameters(self):
        return self._params
    
    #Build the component. Here, 'role' represents the part of the flow
    #expression this component will be, source, sink, operator, monitor
    def build(self, role):
        builder = None
        if role == keywords.SOURCE:
            builder = REGISTRY.lookup_source(self.package.path)
        elif role == keywords.OPERATOR:
            builder = REGISTRY.lookup_operator(self.package.path)
        elif role == keywords.SINK:
            builder = REGISTRY.lookup_sink(self.package.path)
        elif role == keywords.MONITOR:
            builder = REGISTRY.lookup_monitor(self.package.path)
        
        if not builder:
            raise Exception("Could not build {name} as '{role}'".format(name=self.package.path, role=role))
        
        args = self.parameters.args
        kwargs = self.parameters.kwargs
        component = builder(*args, **kwargs)
        component.set_name(self.package.path)
        
        return component


class PackageConstruct(Construct):
    def __init__(self, package, element):
        self._package = package
        self._element = element
    
    @property
    def name(self): return self.path
    
    @property
    def package(self): return self._package
    
    @property
    def element(self): return self._element
    
    @property
    def path(self): return self.package + ("." + self.element if self.element else "")

class ParametersConstruct(Construct):
    def __init__(self, *args, **kwargs):
        self._args = list(args)
        self._kwargs = dict(kwargs)
    
    @property
    def name(self): return "{}, {}".format(self.args, self.kwargs)
    
    @property
    def args(self): return self._args
    
    @property
    def kwargs(self): return self._kwargs

